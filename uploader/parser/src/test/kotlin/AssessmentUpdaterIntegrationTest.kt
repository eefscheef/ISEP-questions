package ut.isep

import Config
import QueryExecutor
import org.junit.jupiter.api.Assertions.*
import org.junit.jupiter.api.BeforeEach
import org.junit.jupiter.api.Test
import org.junit.jupiter.api.io.TempDir
import ut.isep.management.model.entity.*
import java.io.File
import java.nio.file.Path
import kotlin.io.path.pathString

class AssessmentUpdaterIntegrationTest : BaseIntegrationTest() {


    @TempDir
    lateinit var tempDir: Path

    private fun createTestFile(topic: String, filename: String, content: String): File {
        val tempFile = tempDir.resolve("$topic/$filename").toFile()
        tempFile.parentFile.mkdirs()
        tempFile.createNewFile()
        tempFile.writeText(content)
        return tempFile
    }

    @BeforeEach
    override fun openSession() {
        super.openSession()
    }

    @Test
    fun `should handle added question files correctly`() {
        // Arrange
        val topic = "ImaginaryProgramming"
        val filename = "file1.md"
        val content = """
            ---
            type: "multiple-choice"
            tags: 
            - tag1
            availablePoints: 2
            ---
            Some content here.
        """.trimIndent()
        val testFile = createTestFile(topic, filename, content)
        val assessment = Assessment(AssessmentID(tag = "tag1", gitCommitHash = "coolhash"), latest = true)
        TestQueryHelper.persistEntity(assessment, session)

        // Act
        val assessmentUpdater =
            AssessmentUpdater(sessionFactory, Config(listOf("tag1"), listOf("multiple-choice")), "commitHash")
        assessmentUpdater.updateAssessments(addedFilenames = (listOf(testFile.path)))
        // Assert an assignment was uploaded
        val retrievedAssignment = TestQueryHelper.fetchSingle<Assignment>(session) ?: fail("Expected one assignment")
        // Assert the basePath was uploaded correctly
        assertEquals(retrievedAssignment.baseFilePath, tempDir.pathString + "/" + topic + "/" + filename)
        // Assert the assignment type was uploaded correctly
        assertEquals(AssignmentType.MULTIPLE_CHOICE, retrievedAssignment.assignmentType)
        // Assert the availablePoints was uploaded correctly
        assertEquals(2, retrievedAssignment.availablePoints)
        // Assert old file no longer exists
        assertFalse(testFile.isFile)
        // Assert there is one new file which includes the qid of the assignment
        val newTestFiles = tempDir.resolve(topic).toFile().listFiles()
            ?: fail("The assignment file is no longer stored in the expected dir ${tempDir.resolve(topic).pathString}")
        assertEquals(1, newTestFiles.size)
        assertEquals(
            tempDir.pathString + "/" + topic + "/" + "file1_qid${retrievedAssignment.id}.md",
            newTestFiles[0].path
        )

    }

    @Test
    fun `should handle deleted question files correctly`() {
        // Given
        val assignment =
            Assignment(baseFilePath = "file2_qid1234.md", assignmentType = AssignmentType.OPEN, availablePoints = 2)
        val assessment = Assessment(
            id = AssessmentID(tag = "tag2", gitCommitHash = "commit")
        ).apply {
            addSection(Section(title = "section1").apply {
                addAssignment(assignment)
            })
        }
        TestQueryHelper.persistEntity(assessment, session)

        // When
        println("assignment id :${assignment.id}")
        val assessmentUpdater = AssessmentUpdater(sessionFactory, Config(listOf("tag2"), listOf("open")), "commitHash")

        assessmentUpdater.updateAssessments(deletedFilenames = listOf("file2_qid${assignment.id}.md"))

        // Then
        val retrievedAssessment = QueryExecutor(session).getLatestAssessment("tag2")
        assertEquals(0, retrievedAssessment.sections.sumOf { it.assignments.size })
    }

    @Test
    fun `should handle modified question files correctly`() {
        // Arrange: add existing assignment in an assessment to database.
        var existingAssignment =
            Assignment(baseFilePath = "file3.md", assignmentType = AssignmentType.MULTIPLE_CHOICE, availablePoints = 2)
        existingAssignment = TestQueryHelper.persistEntity(existingAssignment, session)
        val existingAssessment = Assessment(AssessmentID("tag3", "previousHash"), latest = true).apply {
            addSection(Section(title = "TestTopic").apply {
                addAssignment(existingAssignment)
            })
        }
        TestQueryHelper.persistEntity(existingAssessment, session)


        val topic = "TestTopic"
        // Arrange: Update filename to store the autogenerated ID
        val filename = "file3_qid${existingAssignment.id}.md"
        val content = """
            ---
            type: "open"
            tags:
            -  "tag3"
            ---
            Modified content here.
        """.trimIndent()
        val testFile = createTestFile(topic, filename, content)

        val assessmentUpdater = AssessmentUpdater(sessionFactory, Config(listOf("tag3"), listOf("open")), "commitHash")

        // When
        assessmentUpdater.updateAssessments(modifiedFilenames = listOf(testFile.path))

        // Then
        val assignments = TestQueryHelper.fetchAll<Assignment>(session)
        assertEquals(2, assignments.size)
        assertEquals(AssignmentType.MULTIPLE_CHOICE, assignments[0].assignmentType)
        assertEquals(AssignmentType.OPEN, assignments[1].assignmentType)
    }

    @Test
    fun `should handle modified config correctly`() {
        // Arrange one non-active assignment in the database, and an active tag in the config
        val existingInactiveAssessment = Assessment(
            id = AssessmentID("inactiveTag", "previousCommitHash"),
            latest = false
        )
        val existingActiveAssessment = Assessment(
            id = AssessmentID("activeTag", "previousCommitHash"),
            latest = true
        )
        TestQueryHelper.persistEntity(existingInactiveAssessment, session)
        TestQueryHelper.persistEntity(existingActiveAssessment, session)
        val config = Config(tagOptions = listOf("newAssessment"), questionOptions = listOf("open", "multipleChoice"))
        val assessmentUpdater = AssessmentUpdater(sessionFactory, config, "newCommitHash")

        // Act: Assessmentupdater updates the database to upload an assessment with the active tag
        assessmentUpdater.updateAssessments(isConfigModified = true)
        session.close()
        val session = sessionFactory.openSession()
        // Assert: we find one active and one inactive assessment, sharing a tag (but not commit hashes)
        val assessments = TestQueryHelper.fetchAll<Assessment>(session)
        assertEquals(3, assessments.size)
        val retrievedOldInactiveAssessment = assessments[0]
        val retrievedOldActiveAssessment = assessments[2]
        val retrievedNewActiveAssessment = assessments[1]

        assertEquals(existingInactiveAssessment.id, retrievedOldInactiveAssessment.id)
        assertFalse(retrievedOldInactiveAssessment.latest)

        assertEquals(existingActiveAssessment.id, retrievedOldActiveAssessment.id)
        assertFalse(retrievedOldActiveAssessment.latest)

        assertEquals("newAssessment", retrievedNewActiveAssessment.id.tag!!)
        assertNotEquals(retrievedNewActiveAssessment.id.gitCommitHash!!, retrievedOldInactiveAssessment.id.gitCommitHash!!)
        assertTrue(retrievedNewActiveAssessment.latest)
        session.close()
    }

    @Test
    fun `should upload updated assessments`() {
        // Given
        val existingAssignment = Assignment(
            baseFilePath = "file4.md", assignmentType = AssignmentType.MULTIPLE_CHOICE, availablePoints = 2
        ).apply {
            TestQueryHelper.persistEntity(this, session)
        }
        val assessment = Assessment(
            id = AssessmentID(tag = "tag4", gitCommitHash = "testCommit"),
        ).apply {
            addSection(Section(title = "section1").apply {
                addAssignment(existingAssignment)
            })
        }
        TestQueryHelper.persistEntity(assessment, session)
        val topic = "Topic1"
        // Arrange: Update filename to store the autogenerated ID
        val filename = "file3_qid${existingAssignment.id}.md"
        // Modify assessment
        val content = """
            ---
            type: "open"
            tags:
            -  "tag4"
            ---
            Updated content here.
        """.trimIndent()
        val testFile = createTestFile(topic, filename, content)

        val assessmentUpdater =
            AssessmentUpdater(sessionFactory, Config(listOf("tag4"), listOf("multiple-choice")), "commitHash")

        // When
        assessmentUpdater.updateAssessments(modifiedFilenames = listOf(testFile.path))

        // Then
        val updatedAssessments = TestQueryHelper.fetchAll<Assessment>(session)
        assertEquals(2, updatedAssessments.size)
        val updatedAssignment = updatedAssessments[1].sections[0].assignments[0]
        assertEquals(AssignmentType.OPEN, updatedAssignment.assignmentType)
    }
}
